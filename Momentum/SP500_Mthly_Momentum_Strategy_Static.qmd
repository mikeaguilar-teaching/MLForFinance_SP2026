---
title: "Momentum Strategy"
subtitle: "Constructing and evaluating a momentum strategy"
author: Mike Aguilar | https://www.linkedin.com/in/mike-aguilar-econ/ 
format: html
editor: visual
toc: true
toc-depth: 5
toc-location: left
embed-resources: true
execute: 
  warning: false
  echo: true
---

# Housekeeping

```{r}
#| echo: false
cat("\014")  # clear console
rm(list=ls())  # Clear the workspace
if (!requireNamespace("here", quietly = TRUE)) install.packages("here")
suppressPackageStartupMessages(library(here))
source(here("Supporting", "PackageLoads.R"))

```

# Data

## Load monthly momentum from GitHub

```{r}
Momentum <- read.csv(here("Data","SP500_Mthly_Momentum.csv"))
```

## Set Test and Train Periods

Task: Create test_date as 9/30/2025 and compute the last train date as one month prior

```{r}
test_date <- as.Date("2025-09-30") 
last_train_date <- as.Date(
  format(test_date, "%Y-%m-01")  ) - 1
```

Task: Create Train.Momentum.Constituents which contains all the dates in the traning period only for the SP500 constituents

```{r}
Train.Momentum.Constituents <- Momentum %>%
  filter(Date <= last_train_date) %>%
  filter(!ticker == "SP500")
```

# Signal Construction

Task: Construct a simple momentum strategy

-   Define LongCondition = 1 if $mom^{Train}_{i} >0$ and 0 otherwise

-   Define ShortCondition = 1 if $mom^{Train}_{i} < 0$ and 0 otherwise

-   $s_{i,t}$ = LongCondition minus ShortCondition

Task: Create a vector that contains the momentum on the last observation of the training period

```{r}

Signal_Matrix <- Train.Momentum.Constituents %>% 
  filter(Date == last_train_date) %>%
  select(Date, ticker, momentum) %>% 
  rename("signal_matrix" = "momentum")

Signal_Matrix
```

# Daily Data for Evaluation

Task: Load SP500 Daily Simple Returns

```{r}
SP500_Daily_SimpleReturns<-read.csv(here("Data","SP500_Daily_SimpleReturns.csv"))
```

Task: ensure Date is Date class

```{r}
SP500_Daily_SimpleReturns <- SP500_Daily_SimpleReturns %>%
  mutate(Date = as.Date(Date))
```

Task: Filter test period (dates AFTER last_train)

```{r}
test_returns <- SP500_Daily_SimpleReturns %>%
  filter(
    Date > as.Date(last_train_date) &
    Date <= as.Date(test_date)
  ) 
```

# Raw Weights

Task: Create a weights dataframe based upon the signal. Set the weight equal to the signal value.

```{r}
weight_df <- Signal_Matrix %>% 
  transmute(
    ticker,
    Date,
    weight = signal_matrix) 
weight_df

```

Task: Construct the portfolio

```{r}
Port.Raw <- construct_portfolio(
    test_returns,
    weight_df,
    # column names in inputs
    date_col   = "Date",
    ticker_col = "ticker",
    return_col = "OneDaySimpleRet",
    weight_col = "weight",
    return_type = "simple", #c("simple","log"),
    rebalance_freq = "monthly", #c("monthly","quarterly","yearly"),
    shift_n = 1 # if shift_n=1 and rebalance_freq=monthly, then w_Jan * ret_Feb
)

```

Task: Plot the port_index over time

```{r}
Port.Raw$portfolio %>%
  ggplot(aes(x = date, y = port_index)) +
  geom_line(color = "blue") +
  labs(title = "Portfolio Index Over Time",
       x = "",
       y = "Portfolio Index") +
  theme_minimal()
```

Task: Display the portfolio holdings

```{r}
head(Port.Raw$holdings, 50)
```

Task: Display the portfolio time series

```{r}
Port.Raw$portfolio
```

Q: What does gross exposure mean?

A:

Gross exposure = sum of absolute weights.

Start with \$1 initial equity (NAV)

Short \$47 worth of stocks.

Use the cash from the short sales to buy \$47 worth of stocks long.

Borrow \$1 to go a total of \$48 long. (i.e. leverage)

Gross exposure = \$48 + \$47 = \$95.

Net exposure = \$48 - \$47 = \$1.

Q: Why can't you use that short sale cash to reduce the amount you borrow in practice?

A: Short sales require margin. You have to keep a percentage of the short sale value in your account as collateral. So you can't just use the cash from the short sale to pay down your borrowings.

Q: Contrast the meaning of gross exposure, pnl, port_ret, port index.

A:

-   Gross exposure = sum of absolute weights. Measures total market exposure.
-   PnL = profit and loss. Measures the dollar gain or loss of the portfolio over a period.
-   Port_ret = portfolio return. Measures the percentage gain or loss of the portfolio over a period.
-   Note that PNL and Port\_ ret are the same in our set up. That is because we use Port_ret = PnL / initial equity. If initial equity = 1, then PnL = Port_ret.
-   Port_index = cumulative value of the portfolio over time, starting from an initial value (usually 1). It reflects the growth of the portfolio over time, in this case, over the days within the test month. Notice how the port index changes across these days, but the gross exposure doesn't change until we rebalance, which we could at the end of the month.

# Fully Invested Weights

Task: Compute the gross_scale as the sum of the signals

```{r}
gross_scale <- sum(abs(Signal_Matrix$signal_matrix))
gross_scale
```

Q: What is the meaning of gross_scale in our strategy context? Why different from gross_exposure?

A:

-   Gross exposure is the sub of the absolute value of the weights.\
-   Gross scale is the sum of the absolute value of the signals before scaling to weights. This tells me how large is my signal vector. This is not scaled to the capital I am putting to work. Signal magnitude, not exposure.

Task: Create fully invested weights dataframe by dividing the signal by gross_scale

```{r}
fullyinvested_weights_df <- weight_df %>%
  mutate(weight = Signal_Matrix$signal_matrix / gross_scale)

sum(abs(fullyinvested_weights_df$weight)) 
```

Q: What's the intuition behind constructing the strategy weights this way?

A:

-   By dividing the signal by gross_scale, we ensure that the sum of the absolute weights equals 1 while respecting the relative strength of the signals.

Task: Construct the portfolio using construct_portfolio

```{r}
Port.FullyInvested <- construct_portfolio(
    test_returns,
    fullyinvested_weights_df,
    # column names in inputs
    date_col   = "Date",
    ticker_col = "ticker",
    return_col = "OneDaySimpleRet",
    weight_col = "weight",
    return_type = "simple", #c("simple","log"),
    rebalance_freq = "monthly", #c("monthly","quarterly","yearly"),
    shift_n = 1 # if shift_n=1 and rebalance_freq=monthly, then w_Jan * ret_Feb
)

```

Task: Plot the port_index over time

```{r}
Port.FullyInvested$portfolio %>%
  ggplot(aes(x = date, y = port_index)) +
  geom_line(color = "blue") +
  labs(title = "Portfolio Index Over Time",
       x = "",
       y = "Portfolio Index") +
  theme_minimal()
```

Task: Create a plot that overlays the two portfolio indices

```{r}
combined_portfolio <- Port.Raw$portfolio %>%
  select(date, raw_port_index = port_index) %>%
  inner_join(
    Port.FullyInvested$portfolio %>%
      select(date, fully_invested_port_index = port_index),
    by = "date"
  )
combined_portfolio %>%
  ggplot(aes(x = date)) +
  geom_line(aes(y = raw_port_index, color = "Raw Weights")) +
  geom_line(aes(y = fully_invested_port_index, color = "Fully Invested Weights")) +
  labs(title = "Portfolio Index Comparison",
       x = "",
       y = "Portfolio Index") +
  scale_color_manual(values = c("Raw Weights" = "blue", "Fully Invested Weights" = "red")) +
  theme_minimal()
```

Q: Why is there such a large difference between these seemingly similar strategies?

A:

-   Using the raw weights takes on much higher gross exposure via leverage.
-   The fully invested weights keep gross exposure at 1.
-   Notice the higher volatility in the raw weights strategy. This is due to the leverage effect, which amplifies both gains and losses. The fully invested strategy, with its controlled exposure, exhibits lower volatility and a more stable growth trajectory.
