---
title: "K Means Momentum Signal"
subtitle: "Constructing and evaluating a momentum signal via K Means"
author: Mike Aguilar | https://www.linkedin.com/in/mike-aguilar-econ/ 
format: html
editor: visual
toc: true
toc-depth: 5
toc-location: left
embed-resources: true
execute: 
  warning: false
  echo: true
---

# Housekeeping

```{r}
#| echo: false
cat("\014")  # clear console
rm(list=ls())  # Clear the workspace
if (!requireNamespace("here", quietly = TRUE)) install.packages("here")
suppressPackageStartupMessages(library(here))

```

# Data

## Load simple returns

Task: Load SP500-Monthly Simple Returns

```{r}
Returns <- ?
```

## Load monthly momentum

```{r}
Momentum <- ?
```

## Merge

Task: Merge the returns and momentum, retaining only those dates with complete information

```{r}
merged_df <- Returns %>%
  left_join(?, ? = c("Date", "ticker"))

```

## Set Test and Train Periods

Task: Create a dataframe for the Train period which spans the beginning of the dataset to Aug2025. Call this dataframe Test. Create a dataframe for the Train period which is Sep2025 period. Call this dataframe Train.

```{r}

test_date <- as.Date("2025-09-30") 
last_train_date <- as.Date(
  format(test_date, "%Y-%m-01")  ) - 1

Train <- merged_df %>% filter(Date ?)
Train.Returns  <- Train %>% select(?)
Train.Momentum <- Train %>% select(?)

Test <- merged_df %>% filter(Date ? test_date)
Test.Returns  <- Test %>% select(?)
Test.Momentum <- Test %>% select(?)

```

## Isolate Index and Constituents

Task: Isolate the returns for the index and the group of constituents into separate dataframes. Repeat for momentum.

```{r}
Train.Constituents <- Train %>%
  filter(?)
Train.Returns.Index <- Train.Returns %>%
  filter(ticker == "SP500")
Train.Returns.Constituents <- Train.Returns %>%
  filter(!ticker == "SP500")
Train.Momentum.Index <- Train.Momentum %>%
  filter(ticker == "SP500")
Train.Momentum.Constituents <- Train.Momentum %>%
  filter(!ticker == "SP500")

Test.Constituents <- Test %>%
  filter(!ticker == "SP500")
Test.Returns.Index <- Test.Returns %>%
  filter(ticker == "SP500")
Test.Returns.Constituents <- Test.Returns %>%
  filter(!ticker == "SP500")
Test.Momentum.Index <- Test.Momentum %>%
  filter(ticker == "SP500")
Test.Momentum.Constituents <- Test.Momentum %>%
  filter(!ticker == "SP500")

```

# Clustering Momentum

## Finding Number of Clusters

Task: Filter the Constituent momentum to only the last date of the Training period

```{r}
mv <- Train.Momentum.Constituents %>%
  filter(Date == ?(Date, na.rm = TRUE)) %>%
  select(momentum) %>%
  na.omit()
```

Task: Convert into a dataframe

```{r}
df_mv <- data.frame(momentum = ?)
```

Task: Choose k_max sensibly

```{r}
k_max <- min(10, nrow(df_mv) - 1)   # or pick another ceiling like 15
if (k_max < 2) stop("Not enough rows to test multiple k values.")
```

Task: Run elbow plot.

-   First, set random seed at 123. Note: the function generates random centroids.
-   Second, set nstart to 25, which implies that this will be run 25 times. Helpful for stability.
-   Third, run fviz_nbclust to create the elbow plot.

```{r}
set.seed(123)
?(df_mv, ?, method = "wss", k.max = k_max, nstart = 25) +
  geom_vline(xintercept = 4, linetype = 2) +
  labs(subtitle = "Elbow Method for Optimal k")
```

Q: How many clusters are suggested?

A: 

Task: Use clusGap to generate Gap statistics. Use the same max K and set B = 50 for the \# of bootstrap samples used.

```{r}
gap_stat <- ?(df_mv, FUN = ?,
                   K.max = k_max, B = ?)
```

Task: use fviz_gap_statistic to plot the gap stat across K

```{r}
?(?) +
  labs(subtitle = "Gap Statistic Method for Optimal k")
```

Q: How many clusters are suggested?

A:




Task: Use silhouette to compute sikhouette scores and then fviz_silhouetee to create silhouette plots for 2,3,4 clusters

```{r}
sil <- ?(kmeans(df_mv$momentum, centers = 2)$cluster,
                  dist(df_mv$momentum))


(?) +
  labs(subtitle = "Silhouette Method for k = 2")

sil <- silhouette(kmeans(df_mv$momentum, centers = 3)$cluster,
                  dist(df_mv$momentum))

fviz_silhouette(sil) +
  labs(subtitle = "Silhouette Method for k = 3")

sil <- silhouette(kmeans(df_mv$momentum, centers = 4)$cluster,
                  dist(df_mv$momentum))

fviz_silhouette(sil) +
  labs(subtitle = "Silhouette Method for k = 4")
```

Q: Interpret the silhouettes. What does it suggest about k?



# Cluster Assignments

Task: Recluster using kmeans with 3 centers

```{r}
momentumclusters<-?(df_mv$momentum, centers = ?)

```

Task: Find the mean momentum in each cluster

```{r}
momentumclusters?
```

Task: Which cluster is long and which short?

```{r}
centers <- momentumclusters$centers[, 1]
LongClusterID <- as.integer(?)
LongClusterID
ShortClusterID <- as.integer(?)
ShortClusterID
```

# Signal Construction

Task: Construct a simple momentum strategy

-   Define LongCondition = 1 if cluster ID = LongClusterID and 0 otherwise

-   Define ShortCondition = 1 if cluster ID = ShortClusterID and 0 otherwise

-   $s_{i,t}$ = LongCondition minus ShortCondition

Task: Create a vector that contains the momentum on the last observation of the training period

```{r}

Signal_Matrix <- ? %>% 
  filter(Date == ?) %>%
  select(ticker, momentum) %>% 
  rename("signal_matrix" = "momentum")

Signal_Matrix
```

Task: Create a vector that takes +1,0,-1 based upon long, neutral, short positioning. Long of signal \> tau. Short if signal less than -tau. Neutral otherwise.

```{r}

Signal_Position <- Signal_Matrix %>%
  mutate(
    cluster = momentumclusters$cluster,
    LongCondition = as.integer(?), 
    ShortCondition = as.integer(?), 
    signal = ?
  ) %>%
  rename("signal_position" = "signal")%>%
  select(ticker,signal_position)

Signal_Position

```

# Evaluate

Task: Format Test period returns to conform to the Signal Testing function

```{r}
test_returns <- Test.Returns.Constituents %>%
  ?(ticker,OneMthSimpleRet) %>%
  rename(test_returns = OneMthSimpleRet)
```

Task: Create meta labels

```{r}
 Meta <- list(
   assetname = "momentum signal",
   benchmarkname = "SP500",
   signalname = "Momentum"
 )
```

Task: Implement the signal evaluation function for return threshold set at the mean of the training period returns

```{r}
return_threshold = mean(Train.Constituents$OneMthSimpleRet)


  SignalEval <- ?(
    test_returns = test_returns,
    Meta = Meta,
    return_threshold = return_threshold,
    signal_position = Signal_Position
  )
```

Q: What does IC suggest about this signal?

A:

```{r}
?
```



Q: What does the hit rate suggest about this signal?

A:

```{r}

```


Q: Use the long short confusion matrix to discuss how you avoided bad trades.

```{r}
SignalEval$TradeResults
SignalEval$?
```

A:
