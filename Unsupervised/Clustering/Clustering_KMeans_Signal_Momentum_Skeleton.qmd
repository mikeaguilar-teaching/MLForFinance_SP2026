---
title: "K Means Momentum Signal"
subtitle: "Constructing and evaluating a momentum signal via K Means"
author: Mike Aguilar | https://www.linkedin.com/in/mike-aguilar-econ/ 
format: html
editor: visual
toc: true
toc-depth: 5
toc-location: left
embed-resources: true
execute: 
  warning: false
  echo: true
---

# Housekeeping

```{r}
#| echo: false
cat("\014")  # clear console
rm(list=ls())  # Clear the workspace
if (!requireNamespace("here", quietly = TRUE)) install.packages("here")
suppressPackageStartupMessages(library(here))
source(here("Supporting", "PackageLoads.R"))
```

# Data

## Load simple returns

Task: Load SP500-Monthly Simple Returns

```{r}
Returns <- read.csv(?("Data","SP500_Mthly_SimpleReturns.csv"))
```

## Load monthly momentum

```{r}
Momentum <- read.csv(?("Data","SP500_Mthly_Momentum.csv"))
```

## Merge

Task: Merge the returns and momentum, retaining only those dates with complete information

```{r}
merged_df <- Returns %>%
  left_join(Momentum, by = c("?", "ticker"))

```

## Set Test and Train Periods

Task: Create a dataframe for the Train period which spans the beginning of the dataset to Aug2025. Call this dataframe Test. Create a dataframe for the Train period which is Sep2025 period. Call this dataframe Train.

```{r}

test_date <- as.Date("2025-09-30") 
last_train_date <- as.Date(
  format(test_date, "%Y-%m-01")  ) - 1

Train <- merged_df %>% filter(Date ? test_date)
Train.Returns  <- Train %>% select(!momentum)
Train.Momentum <- Train %>% select(!OneMthSimpleRet)

Test <- merged_df %>% filter(Date ? test_date)
Test.Returns  <- Test %>% select(!momentum)
Test.Momentum <- Test %>% select(!OneMthSimpleRet)

```

## Isolate Index and Constituents

Task: Isolate the returns for the index and the group of constituents into separate dataframes. Repeat for momentum.

```{r}
Train.Constituents <- Train %>%
  filter(?)
Train.Returns.Index <- Train.Returns %>%
  filter(?)
Train.Returns.Constituents <- Train.Returns %>%
  filter(?)
Train.Momentum.Index <- Train.Momentum %>%
  filter(?)
Train.Momentum.Constituents <- Train.Momentum %>%
  filter(?)

Test.Constituents <- Test %>%
  filter(!ticker == "SP500")
Test.Returns.Index <- Test.Returns %>%
  filter(ticker == "SP500")
Test.Returns.Constituents <- Test.Returns %>%
  filter(!ticker == "SP500")
Test.Momentum.Index <- Test.Momentum %>%
  filter(ticker == "SP500")
Test.Momentum.Constituents <- Test.Momentum %>%
  filter(!ticker == "SP500")

```

# Clustering Momentum

## Finding Number of Clusters

Task: Filter the Constituent momentum to only the last date of the Training period

```{r}
mv <- Train.Momentum.Constituents %>%
  filter(Date == ?(Date, na.rm = TRUE)) %>%
  select(momentum) %>%
  na.omit()
```

Task: Convert into a dataframe

```{r}
df_mv <- data.frame(momentum = mv)
```

Task: Choose k_max sensibly

```{r}
k_max <- min(10, nrow(df_mv) - 1)   # or pick another ceiling like 15
if (k_max < 2) stop("Not enough rows to test multiple k values.")
```

Task: Run elbow plot.

-   First, set random seed at 123. Note: the function generates random centroids.
-   Second, set nstart to 25, which implies that this will be run 25 times. Helpful for stability.
-   Third, run fviz_nbclust to create the elbow plot.

```{r}
set.seed(?)
fviz_nbclust(?, kmeans, method = "wss", k.max = ?, nstart = ?) +
  geom_vline(xintercept = 4, linetype = 2) +
  labs(subtitle = "Elbow Method for Optimal k")
```

Q: How many clusters are suggested?

A: 

Task: Use clusGap to generate Gap statistics. Use the same max K and set B = 50 for the \# of bootstrap samples used.

```{r}
gap_stat <- clusGap(?, FUN = kmeans,
                   K.max = ?, B = ?)
```

Task: use fviz_gap_statistic to plot the gap stat across K

```{r}
fviz_gap_stat(?) +
  labs(subtitle = "Gap Statistic Method for Optimal k")
```

Q: How many clusters are suggested?

A:



Task: Use silhouette to compute sikhouette scores and then fviz_silhouetee to create silhouette plots for 2,3,4 clusters

```{r}
sil <- ?(kmeans(df_mv$momentum, centers = 2)$cluster,
                  dist(df_mv$momentum))

fviz_silhouette(sil) +
  labs(subtitle = "Silhouette Method for k = 2")

sil <- silhouette(kmeans(df_mv$momentum, centers = ?)$cluster,
                  dist(df_mv$momentum))

fviz_silhouette(sil) +
  labs(subtitle = "Silhouette Method for k = 3")

sil <- silhouette(kmeans(df_mv$momentum, centers = ?)$cluster,
                  dist(df_mv$momentum))

fviz_silhouette(sil) +
  labs(subtitle = "Silhouette Method for k = 4")
```

Q: Interpret the silhouettes. What does it suggest about k?

A: 


# Cluster Assignments

Task: Recluster using kmeans with 3 centers

```{r}
momentumclusters<-?(df_mv$momentum, centers = ?)

```

Task: Find the mean momentum in each cluster

```{r}
momentumclusters$?
```

Task: Which cluster is long and which short?

```{r}
centers <- momentumclusters$centers[, 1]
LongClusterID <- as.integer(which.?(centers))
LongClusterID
ShortClusterID <- as.integer(which.?(centers))
ShortClusterID
```

# Signal Construction

Task: Construct a simple momentum strategy

-   Define LongCondition = 1 if cluster ID = LongClusterID and 0 otherwise

-   Define ShortCondition = 1 if cluster ID = ShortClusterID and 0 otherwise

-   $s_{i,t}$ = LongCondition minus ShortCondition

Task: Create a vector that contains the momentum on the last observation of the training period

```{r}

Signal_Matrix <- ? %>% 
  filter(Date ?last_train_date) %>%
  select(ticker, momentum) %>% 
  rename("signal_matrix" = "momentum")

Signal_Matrix
```

Task: Create a vector that takes +1,0,-1 based upon long, neutral, short positioning. Long of signal \> tau. Short if signal less than -tau. Neutral otherwise.

```{r}

Signal_Position <- Signal_Matrix %>%
  mutate(
    cluster = ?,
    LongCondition = as.integer(cluster == ?), 
    ShortCondition = as.integer(cluster == ?), 
    signal = ?
  ) %>%
  rename("signal_position" = "signal")%>%
  select(ticker,signal_position)

Signal_Position

```

# Evaluate

Task: Format Test period returns to conform to the Signal Testing function

```{r}
test_returns <- Test.Returns.Constituents %>%
  select(ticker,OneMthSimpleRet) %>%
  rename(test_returns = OneMthSimpleRet)
```

Task: Create meta labels

```{r}
 Meta <- list(
   assetname = "momentum signal",
   benchmarkname = "SP500",
   signalname = "Momentum"
 )
```

Task: Implement the signal evaluation function for return threshold set at the mean of the training period returns

```{r}
return_threshold = ?(Train.Constituents$OneMthSimpleRet)


  SignalEval <- signal_evaluation_static(
    test_returns = ?,
    Meta = Meta,
    return_threshold = ?,
    signal_position = Signal_Position
  )
```

Task: Display the Trade Results
```{r}
SignalEval$?
```

Q: How active is this signal? 

A: T

Task: Display the return comparison table
```{r}
SignalEval?
```
Q: Is the signal profitable?

A: 



Task: Display the IC summary table
```{r}
SignalEval?
```

Q: What does IC suggest about this signal?

A:
?

Task: Display the hit table
```{r}
SignalEval?
```
Q: What does the hit rate suggest about this signal?

A:

?

Task: Display the confusion report
```{r}

SignalEval$?
```

Q: Use the long short confusion matrix to discuss how you avoided bad trades.


A:

